---
title: "Data Cleaning"
date: "Created: 2017-05-17 <br> Updated: `r Sys.Date()`"
output: github_document
---

```{r load_packages, message=FALSE}
# Load packages
library(tidyverse)
library(feather)
library(forcats)

# devtools::install_github("brad-cannell/my_functions")
library(myFunctions)
```

```{r load_data}
calls   <- read_feather("../data/calls.feather")
klarus  <- read_feather("../data/klarus.feather")
medstar <- read_feather("../data/medstar.feather")
```

Need to join the Klarus patient list to 911 calls using:   
* id   
* 911 encounter date needs to fall within Klarus start and end date.   
* Every row in the 911 data should have a matching row in the Klarus data. If not, I need to let Daniel know the id, response #, and incident #.

To check for rows in the 911 data that don't have a match in the Klarus data, I'm going to give each row a sequential number. I'm also going to create a vector that is equal to 1 through the number of rows in the calls data. After merging the two data sets, I will check for missing row numbers.

```{r check_matches}
calls$row <- 1:nrow(calls)
check <- 1:nrow(calls)
```

```{r merge_data}
# Attach calls to the patient list
klarus_calls <- left_join(klarus, calls, by = "id")
```

Look for rows from the 911 calls data that don't exist in the merged data.

```{r}
merged_rows <- klarus_calls$row %>% unique %>% sort
no_match <- setdiff(check, merged_rows)
no_match
```

There are 24 rows that appear in the 911 calls data, but not in the klarus data. I'm going to export these rows as a csv file, and send to Daniel for confirmation.

```{r}
# no_match_rows <- filter(calls, row %in% no_match)
# no_match_rows
```

```{r}
# write_csv(no_match_rows, "../data/no_match_rows.csv")
```

**2017-06-23 from Daniel Ebbett:** 

> Dan Bruce called me regarding the missing rows today. These 911 calls can be excluded from the review. If you want the more in depth explanation let me know and I can give you a call to give you the info. 

These 24 911 calls are already missing from the joined data. Nothing else needs to be done.

#### Filtering by dates

Now the 911 calls are joined to the Klarus patient list by ID. However, I only want to keep the rows where the 911 encounter date falls within Klarus start and end date.

```{r filter_join}
klarus_calls <- filter(klarus_calls, start_date <= encounter_date & encounter_date <= end_date)
about_data(klarus_calls) # 374 observations and 33 variables
```

#### Merge with death dates

```{r}
medstar_death <- select(medstar, id, death_date) %>% filter(!is.na(death_date))
medstar_death$id %>% unique() %>% length() # 36. No duplicate ids.
```

```{r}
klarus_calls <- left_join(klarus_calls, medstar_death, by = "id")
about_data(klarus_calls) # 374 observations and 34 variables
```

```{r}
# Save progress
write_feather(klarus_calls, "../data/klarus_calls.feather")
```

---









# Variable Management

```{r}
klarus_calls <- read_feather("../data/klarus_calls.feather")
about_data(klarus_calls) # 374 observations and 34 variables
```

Recode call priority

```{r}
klarus_calls$call_priority <- fct_collapse(klarus_calls$call_priority,
  "1" = c("1", "P1", "C1"),
  "2" = c("2", "P2", "C2"),
  "3" = c("3", "P3", "C3")
)
```

Factorize selected character variables

```{r}
vars <- c("gender", "zip", "primary_diagnosis", "secondary_diagnosis", "encounter_type", "encounter_type",
          "determinant", "ems_encounter_outcome", "transported", "mhp_on_scene", "vehicle_unit",
          "mhp_no_os_preventable", "mhp_one", "mhp_two", "receiving_facility")


klarus_calls <- klarus_calls %>% 
  map_at(., vars, function(x) {
    x <- factor(x)
    x
  }) %>% 
  as_tibble()

about_data(klarus_calls) # 374 observations and 34 variables
```

```{r}
# Save progress
write_feather(klarus_calls, "../data/klarus_calls.feather")
```

```{r session_info, echo=FALSE}
sessionInfo()
```
